<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Django CBV编程中类似于DetailView单个对象方法执行顺序 - 肖郎的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Django Class Based View已经很方便了，但是总是需要自定义的地方。例如有时候需要对DetailView类中方法进行重载。这时候需要对类中各种方法的作用和执行顺序很清楚。">
<meta property="og:type" content="article">
<meta property="og:title" content="Django CBV编程中类似于DetailView单个对象方法执行顺序">
<meta property="og:url" content="http://shawlang.github.io/2015/09/21/Django-CBV编程中类似于DetailView单个对象方法执行顺序/index.html">
<meta property="og:site_name" content="肖郎的博客">
<meta property="og:description" content="Django Class Based View已经很方便了，但是总是需要自定义的地方。例如有时候需要对DetailView类中方法进行重载。这时候需要对类中各种方法的作用和执行顺序很清楚。">
<meta property="og:image" content="http://www.designerspics.com/wp-content/uploads/2014/09/tree_root_free_photo-690x457.jpg">
<meta property="og:updated_time" content="2015-09-20T23:27:48.434Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Django CBV编程中类似于DetailView单个对象方法执行顺序">
<meta name="twitter:description" content="Django Class Based View已经很方便了，但是总是需要自定义的地方。例如有时候需要对DetailView类中方法进行重载。这时候需要对类中各种方法的作用和执行顺序很清楚。">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <a id="logo" class="logo" href="/"></a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">存档</a>
        
          <a class="main-nav-link" href="/categories">分类</a>
        
          <a class="main-nav-link" href="/tags">标签</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
          <a class="main-nav-link" href="/sideproject">个人项目</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <input type="text" class="st-default-search-input" />
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer"><article id="post-Django-CBV编程中类似于DetailView单个对象方法执行顺序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Django CBV编程中类似于DetailView单个对象方法执行顺序
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/09/21/Django-CBV编程中类似于DetailView单个对象方法执行顺序/" class="article-date">
  <time datetime="2015-09-20T22:41:53.000Z" itemprop="datePublished">2015-09-21</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Django-CBV/">Django CBV</a>
  </div>

      
        <div class="article-comment-link-wrap">
          <a href="http://shawlang.github.io/2015/09/21/Django-CBV编程中类似于DetailView单个对象方法执行顺序/#disqus_thread" class="article-comment-link">评论</a>
        </div>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="http://www.designerspics.com/wp-content/uploads/2014/09/tree_root_free_photo-690x457.jpg" alt="哎呦！我怎么看到很多小人盘结在一起..."></p>
<p>Django Class Based View已经很方便了，但是总是需要自定义的地方。例如有时候需要对DetailView类中方法进行重载。这时候需要对类中各种方法的作用和执行顺序很清楚。</p>
<a id="more"></a>
<p>这里贴一下SingleObjectMixin类的官方源码，做个记录：</p>
<pre><code><span class="keyword">from</span> __future__ <span class="keyword">import</span> unicode_literals

<span class="keyword">from</span> django.core.exceptions <span class="keyword">import</span> ImproperlyConfigured
<span class="keyword">from</span> django.db <span class="keyword">import</span> models
<span class="keyword">from</span> django.http <span class="keyword">import</span> Http404
<span class="keyword">from</span> django.utils.translation <span class="keyword">import</span> ugettext <span class="keyword">as</span> _
<span class="keyword">from</span> django.views.generic.base <span class="keyword">import</span> ContextMixin, TemplateResponseMixin, View


<span class="class"><span class="keyword">class</span> <span class="title">SingleObjectMixin</span><span class="params">(ContextMixin)</span>:</span>
    <span class="string">"""
    Provides the ability to retrieve a single object for further manipulation.
    """</span>
    model = <span class="keyword">None</span>
    queryset = <span class="keyword">None</span>
    slug_field = <span class="string">'slug'</span>
    context_object_name = <span class="keyword">None</span>
    slug_url_kwarg = <span class="string">'slug'</span>
    pk_url_kwarg = <span class="string">'pk'</span>
    query_pk_and_slug = <span class="keyword">False</span>

<span class="function"><span class="keyword">def</span> <span class="title">get_object</span><span class="params">(self, queryset=None)</span>:</span>
    <span class="string">"""
    Returns the object the view is displaying.
    By default this requires `self.queryset` and a `pk` or `slug` argument
    in the URLconf, but subclasses can override this to return any object.
    """</span>
    <span class="comment"># Use a custom queryset if provided; this is required for subclasses</span>
    <span class="comment"># like DateDetailView</span>
    <span class="keyword">if</span> queryset <span class="keyword">is</span> <span class="keyword">None</span>:
        queryset = self.get_queryset()

    <span class="comment"># Next, try looking up by primary key.</span>
    pk = self.kwargs.get(self.pk_url_kwarg)
    slug = self.kwargs.get(self.slug_url_kwarg)
    <span class="keyword">if</span> pk <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:
        queryset = queryset.filter(pk=pk)

    <span class="comment"># Next, try looking up by slug.</span>
    <span class="keyword">if</span> slug <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> (pk <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> self.query_pk_and_slug):
        slug_field = self.get_slug_field()
        queryset = queryset.filter(**{slug_field: slug})

    <span class="comment"># If none of those are defined, it's an error.</span>
    <span class="keyword">if</span> pk <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> slug <span class="keyword">is</span> <span class="keyword">None</span>:
        <span class="keyword">raise</span> AttributeError(<span class="string">"Generic detail view %s must be called with "</span>
                             <span class="string">"either an object pk or a slug."</span>
                             % self.__class__.__name__)

    <span class="keyword">try</span>:
        <span class="comment"># Get the single item from the filtered queryset</span>
        obj = queryset.get()
    <span class="keyword">except</span> queryset.model.DoesNotExist:
        <span class="keyword">raise</span> Http404(_(<span class="string">"No %(verbose_name)s found matching the query"</span>) %
                      {<span class="string">'verbose_name'</span>: queryset.model._meta.verbose_name})
    <span class="keyword">return</span> obj

<span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span>
    <span class="string">"""
    Return the `QuerySet` that will be used to look up the object.
    Note that this method is called by the default implementation of
    `get_object` and may not be called if `get_object` is overridden.
    """</span>
    <span class="keyword">if</span> self.queryset <span class="keyword">is</span> <span class="keyword">None</span>:
        <span class="keyword">if</span> self.model:
            <span class="keyword">return</span> self.model._default_manager.all()
        <span class="keyword">else</span>:
            <span class="keyword">raise</span> ImproperlyConfigured(
                <span class="string">"%(cls)s is missing a QuerySet. Define "</span>
                <span class="string">"%(cls)s.model, %(cls)s.queryset, or override "</span>
                <span class="string">"%(cls)s.get_queryset()."</span> % {
                    <span class="string">'cls'</span>: self.__class__.__name__
                }
            )
    <span class="keyword">return</span> self.queryset.all()

<span class="function"><span class="keyword">def</span> <span class="title">get_slug_field</span><span class="params">(self)</span>:</span>
    <span class="string">"""
    Get the name of a slug field to be used to look up by slug.
    """</span>
    <span class="keyword">return</span> self.slug_field

<span class="function"><span class="keyword">def</span> <span class="title">get_context_object_name</span><span class="params">(self, obj)</span>:</span>
    <span class="string">"""
    Get the name to use for the object.
    """</span>
    <span class="keyword">if</span> self.context_object_name:
        <span class="keyword">return</span> self.context_object_name
    <span class="keyword">elif</span> isinstance(obj, models.Model):
        <span class="keyword">if</span> self.object._deferred:
            obj = obj._meta.proxy_for_model
        <span class="keyword">return</span> obj._meta.model_name
    <span class="keyword">else</span>:
        <span class="keyword">return</span> <span class="keyword">None</span>

<span class="function"><span class="keyword">def</span> <span class="title">get_context_data</span><span class="params">(self, **kwargs)</span>:</span>
    <span class="string">"""
    Insert the single object into the context dict.
    """</span>
    context = {}
    <span class="keyword">if</span> self.object:
        context[<span class="string">'object'</span>] = self.object
        context_object_name = self.get_context_object_name(self.object)
        <span class="keyword">if</span> context_object_name:
            context[context_object_name] = self.object
    context.update(kwargs)
    <span class="keyword">return</span> super(SingleObjectMixin, self).get_context_data(**context)


<span class="class"><span class="keyword">class</span> <span class="title">BaseDetailView</span><span class="params">(SingleObjectMixin, View)</span>:</span>
    <span class="string">"""
    A base view for displaying a single object
    """</span>
    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, *args, **kwargs)</span>:</span>
        self.object = self.get_object()
        context = self.get_context_data(object=self.object)
        <span class="keyword">return</span> self.render_to_response(context)


<span class="class"><span class="keyword">class</span> <span class="title">SingleObjectTemplateResponseMixin</span><span class="params">(TemplateResponseMixin)</span>:</span>
    template_name_field = <span class="keyword">None</span>
    template_name_suffix = <span class="string">'_detail'</span>

    <span class="function"><span class="keyword">def</span> <span class="title">get_template_names</span><span class="params">(self)</span>:</span>
        <span class="string">"""
        Return a list of template names to be used for the request. May not be
        called if render_to_response is overridden. Returns the following list:
        * the value of ``template_name`` on the view (if provided)
        * the contents of the ``template_name_field`` field on the
          object instance that the view is operating upon (if available)
        * ``&lt;app_label&gt;/&lt;model_name&gt;&lt;template_name_suffix&gt;.html``
        """</span>
        <span class="keyword">try</span>:
            names = super(SingleObjectTemplateResponseMixin, self).get_template_names()
        <span class="keyword">except</span> ImproperlyConfigured:
            <span class="comment"># If template_name isn't specified, it's not a problem --</span>
            <span class="comment"># we just start with an empty list.</span>
            names = []

            <span class="comment"># If self.template_name_field is set, grab the value of the field</span>
            <span class="comment"># of that name from the object; this is the most specific template</span>
            <span class="comment"># name, if given.</span>
            <span class="keyword">if</span> self.object <span class="keyword">and</span> self.template_name_field:
                name = getattr(self.object, self.template_name_field, <span class="keyword">None</span>)
                <span class="keyword">if</span> name:
                    names.insert(<span class="number">0</span>, name)

            <span class="comment"># The least-specific option is the default &lt;app&gt;/&lt;model&gt;_detail.html;</span>
            <span class="comment"># only use this if the object in question is a model.</span>
            <span class="keyword">if</span> isinstance(self.object, models.Model):
                object_meta = self.object._meta
                <span class="keyword">if</span> self.object._deferred:
                    object_meta = self.object._meta.proxy_for_model._meta
                names.append(<span class="string">"%s/%s%s.html"</span> % (
                    object_meta.app_label,
                    object_meta.model_name,
                    self.template_name_suffix
                ))
            <span class="keyword">elif</span> hasattr(self, <span class="string">'model'</span>) <span class="keyword">and</span> self.model <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> issubclass(self.model, models.Model):
                names.append(<span class="string">"%s/%s%s.html"</span> % (
                    self.model._meta.app_label,
                    self.model._meta.model_name,
                    self.template_name_suffix
                ))

            <span class="comment"># If we still haven't managed to find any template names, we should</span>
            <span class="comment"># re-raise the ImproperlyConfigured to alert the user.</span>
            <span class="keyword">if</span> <span class="keyword">not</span> names:
                <span class="keyword">raise</span>

        <span class="keyword">return</span> names

<span class="class"><span class="keyword">class</span> <span class="title">DetailView</span><span class="params">(SingleObjectTemplateResponseMixin, BaseDetailView)</span>:</span>
    <span class="string">"""
    Render a "detail" view of an object.
    By default this is a model instance looked up from `self.queryset`, but the
    view will support display of *any* object by overriding `self.get_object()`.
    """</span>
</code></pre><p>这里还涉及到一个多重继承类方法执行顺序的问题，暂且把问题留在这里。</p>
<h3 id="参考资料">参考资料</h3><p><a href="https://github.com/django/django/tree/master/django/views/generic#L177" target="_blank" rel="external">https://github.com/django/django/tree/master/django/views/generic#L177</a></p>

      
    </div>
  
    <footer class="article-footer">
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DetailView/">DetailView</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Django/">Django</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Django-CBV/">Django CBV</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/singleObjectMixin/">singleObjectMixin</a></li></ul>

    </footer>
  
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2015/09/18/使用get-absolute-url函数改变模板超链接硬编码/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">使用get_absolute_url函数改变模板超链接硬编码&nbsp;<span>&gt;</span></div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
</section>
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 10月2日 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3242134977510351"
     data-ad-slot="9186297966"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 shawlang&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>

</footer>
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','hpwehiRPuuBriefhgg56','2.0.0');
</script>
    
<script>
  var disqus_developer=1;
  var disqus_shortname = 'shawlang';
  
  var disqus_url = 'http://shawlang.github.io/2015/09/21/Django-CBV编程中类似于DetailView单个对象方法执行顺序/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>